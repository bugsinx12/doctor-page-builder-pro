// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { useAuth } from '@clerk/clerk-react';

// Supabase project URL and anonymous key
const SUPABASE_URL = "https://isjjzddntanbjopqylic.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlzamp6ZGRudGFuYmpvcHF5bGljIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NzEyMDAsImV4cCI6MjA2MDE0NzIwMH0._Y8ux53LbbT5aAVAyHJduvMGvHuBmKD34fU6xktyjR8";

// Create a Supabase client for anonymous access
// This client will be used when users are not authenticated
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    storage: localStorage
  },
  global: {
    headers: {
      'x-application-name': 'doctor-landing-pages',
    },
  },
});

/**
 * Creates an authenticated Supabase client using a Clerk token
 * This function sets up a Supabase client with the token in the Authorization header
 * 
 * @param token JWT token from Clerk
 * @returns Authenticated Supabase client
 */
export const getAuthenticatedClient = (token: string) => {
  console.log("Creating authenticated Supabase client with token");
  
  return createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
    global: {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    },
  });
};

/**
 * Returns a Supabase client configured with Clerk authentication.
 * This implements the pattern from Clerk documentation for Third-Party Auth (TPA).
 */
export const getClerkAuthenticatedClient = async () => {
  const { getToken } = useAuth();
  
  // Get token using the JWT template configured in Clerk
  const token = await getToken();
  
  if (!token) {
    console.error("No authentication token available from Clerk");
    return supabase; // Return anonymous client as fallback
  }
  
  return createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      persistSession: false,
      autoRefreshToken: false,
    },
    global: {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    },
  });
};

// Helper function to create a singleton client with Clerk authentication
let authenticatedClient: ReturnType<typeof createClient<Database>> | null = null;

export const useSupabaseClient = async () => {
  const { getToken } = useAuth();
  
  if (!authenticatedClient) {
    const token = await getToken();
    
    if (token) {
      authenticatedClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
        auth: {
          autoRefreshToken: false,
          persistSession: false,
        },
        global: {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        },
      });
    } else {
      return supabase; // Return anonymous client as fallback
    }
  }
  
  return authenticatedClient;
};

/**
 * Helper function to check if the current user has a valid session
 * @returns Object with session status
 */
export const getSessionStatus = async () => {
  try {
    const { data, error } = await supabase.auth.getSession();
    if (error) {
      console.error("Error getting session:", error);
      return { hasSession: false, error };
    }
    
    return { hasSession: !!data.session, session: data.session };
  } catch (error) {
    console.error("Unexpected error checking session:", error);
    return { hasSession: false, error };
  }
};

/**
 * Tests the TPA (Third Party Authentication) integration between Clerk and Supabase
 * @param token Clerk JWT token 
 * @returns Result of authentication test
 */
export const testClerkTPAAuthentication = async (token: string) => {
  try {
    if (!token) {
      return { success: false, message: "No authentication token provided" };
    }
    
    // Create client with token
    const client = getAuthenticatedClient(token);
    
    // Test if authentication works by trying to get user data
    const { data, error } = await client.auth.getUser();
    
    if (error) {
      console.error("TPA authentication error:", error);
      return { 
        success: false, 
        message: `Authentication failed: ${error.message}`,
        error 
      };
    }
    
    if (!data.user) {
      return { 
        success: false,
        message: "No user data returned from authentication check" 
      };
    }
    
    // Authentication successful
    return { 
      success: true,
      message: "Clerk-Supabase TPA integration is working correctly",
      user: data.user
    };
  } catch (error) {
    console.error("Error testing TPA authentication:", error);
    return { 
      success: false, 
      message: "Unexpected error during authentication test",
      error 
    };
  }
};

/**
 * Debugging function to log the session and tokens
 */
export const debugSessionInfo = async (client = supabase) => {
  try {
    console.log("Debugging Session Information");
    
    // Get current session
    const { data: sessionData, error: sessionError } = await client.auth.getSession();
    
    if (sessionError) {
      console.error("Error retrieving session:", sessionError);
      return { success: false, error: sessionError };
    }
    
    if (!sessionData.session) {
      console.log("No active Supabase session found");
      return { success: false, message: "No active session" };
    }
    
    // Log session details for debugging
    console.log("Active Supabase session:", {
      userId: sessionData.session.user.id,
      email: sessionData.session.user.email,
      lastSignIn: sessionData.session.user.last_sign_in_at,
      expiresAt: new Date(sessionData.session.expires_at * 1000).toISOString(),
      providerToken: !!sessionData.session.provider_token,
      providerRefreshToken: !!sessionData.session.provider_refresh_token,
      clerkId: sessionData.session.user.user_metadata?.clerk_id || sessionData.session.user.user_metadata?.sub,
      metadata: sessionData.session.user.user_metadata,
    });
    
    return {
      success: true,
      session: sessionData.session,
      user: sessionData.session.user
    };
  } catch (error) {
    console.error("Unexpected error debugging session:", error);
    return { success: false, error };
  }
};
